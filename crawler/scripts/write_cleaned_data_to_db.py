#!/usr/bin/env python

import dataclasses
import typing
import sys
from sqlalchemy import select

from lib.recipes import (
    Session,
    RecipeRaw,
    Recipe,
    RecipeIngredient,
    Ingredient,
    MeasurementUnit
)
from tqdm import tqdm
from crawler import settings
import redis
import json
import structlog
import logging


logging.basicConfig(
    format="%(message)s",
    stream=sys.stdout,
    level=logging.ERROR
)

structlog.configure()

logger: structlog.stdlib.BoundLogger = structlog.get_logger()

cache = redis.StrictRedis(
    host=settings.config["redis"]["host"],
    port=settings.config["redis"]["port"]
)


def get_ingredients(recipe_id: int) -> typing.Optional[typing.List[typing.Dict[str, typing.Any]]]:
    value = cache.get(f"chat_gpt3_parsed:{recipe_id}")
    if value is not None:
        return json.loads(value.decode('utf-8'))

@dataclasses.dataclass
class ParsedIngredient:
    quantity: typing.Optional[float]
    unit: typing.Optional[str]
    canonical_name: typing.Optional[str]
    extra_notes: typing.Optional[str]


def main():
    with Session(autoflush=True) as session:
        for raw in tqdm(session.scalars(select(RecipeRaw)).all()):
            parsed_ingredients = get_ingredients(raw.id)
            if parsed_ingredients is None:
                continue
            if isinstance(parsed_ingredients, dict):
                parsed_ingredients = list(parsed_ingredients.values())
                if len(parsed_ingredients) == 1:
                    parsed_ingredients = parsed_ingredients[0]
                if len(parsed_ingredients) == 1:
                    continue

            for parsed_ingredient in parsed_ingredients:
                try:
                    ingredient = ParsedIngredient(**parsed_ingredient)
                except TypeError as err:
                    logger.error(f"malformed data generated by GPT-3: {err}", recipe=raw.id)
                    continue

                if ingredient.canonical_name is None:
                    logger.error("Canonical name does not exist.", ingredient=ingredient, recipe=raw.id)
                    continue
                if ingredient.unit is None:
                    logger.error("No unit exists.", ingredient=ingredient, recipe=raw.id)
                    continue

                ingredient_record = _get_or_create_ingredient(session, ingredient.canonical_name)
                unit_record = _get_or_create_measurement_unit(session, ingredient.unit)
                recipe_record = parse_recipe(session, raw)

                recipe_ingredient_record = RecipeIngredient(
                    recipe_id=recipe_record.id,
                    ingredient_id=ingredient_record.id,
                    measurement_unit_id=unit_record.id,
                    quantity=ingredient.quantity,
                    extra_notes=ingredient.extra_notes
                )
                session.add(recipe_ingredient_record)

        session.commit()


def _get_or_create_ingredient(session, name: str) -> Ingredient:
    stmt = (
        select(Ingredient)
        .where(Ingredient.canonical_name == name.strip().lower())
    )
    row = session.scalar(stmt)
    if row:
        return row

    row = Ingredient(canonical_name=name.strip().lower())
    session.add(row)
    return row


def _get_or_create_measurement_unit(session, name: str) -> Ingredient:
    stmt = (
        select(MeasurementUnit)
        .where(MeasurementUnit.name == name.strip().lower())
    )
    row = session.scalar(stmt)
    if row:
        return row

    record = MeasurementUnit(name=name.strip().lower())
    session.add(record)
    return record


def parse_recipe(session, raw: RecipeRaw) -> Recipe:
    contents = dict(raw.payload)
    name = contents.pop("title", None)
    url = contents.pop("canonical_url", None)
    description = contents.pop("description", None)
    instructions = contents.pop("instructions_list", None)
    extra = contents

    # Get the recipe by url initially.
    recipe_stmt = (
        select(Recipe)
        .where(Recipe.url == url.strip())
    )

    recipe = session.scalar(recipe_stmt)
    if recipe:
        return recipe

    recipe = Recipe(
        id=raw.id,
        url=url.strip(),
        name=name.strip(),
        description=description,
        instructions=instructions,
        scraped_extra=extra
    )
    session.add(recipe)
    return recipe


if __name__ == '__main__':
    main()
